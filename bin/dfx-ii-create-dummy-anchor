#!/usr/bin/env bash

set -euo pipefail

SOURCE_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"

print_help() {
  cat <<-EOF

	Creates a dummy internet identity with a registered backup device and seed 
  phrase. This makes it easy to sign in with the fewer number of clicks.
	EOF
}

# Source the clap.bash file ---------------------------------------------------
source "$SOURCE_DIR/clap.bash"
# Define options
clap.define short=n long=network desc="The dfx network to use" variable=DFX_NETWORK default="local"
clap.define short=i long=identity desc="The dfx identity to use" variable=DFX_IDENTITY default="$(dfx identity whoami)"
# Source the output file ----------------------------------------------------------
source "$(clap.build)"

IDENTITY_PUB_KEY_FILE="$(mktemp)"

clean_up() {
  rm "$IDENTITY_PUB_KEY_FILE"
}

trap clean_up EXIT

dfx identity export "$DFX_IDENTITY" | openssl ec -out "$IDENTITY_PUB_KEY_FILE" -pubout -outform der 2>/dev/null

echo "Fetching captcha."
CHALLENGE_KEY="$(dfx canister call internet_identity create_challenge --network "$DFX_NETWORK" --candid "$(jq -r .canisters.internet_identity.candid dfx.json)" | idl2json | jq -r .challenge_key)"

PUB_KEY_BLOB=$(hexdump -ve '1/1 "%.2x"' "$IDENTITY_PUB_KEY_FILE" | sed 's/../\\&/g')

echo "Creating anchor."
ANCHOR_CREATION_RESPONSE="$(dfx canister call internet_identity register "(record{pubkey=blob \"${PUB_KEY_BLOB}\";alias=\"dfx test key\";purpose=variant{authentication};key_type=variant{unknown};protection=variant{unprotected};},record{key=\"${CHALLENGE_KEY}\";chars=\"a\"},null)" --network "$DFX_NETWORK")"
ANCHOR="$(echo "$ANCHOR_CREATION_RESPONSE" | idl2json | jq -r .registered.user_number)"

# Verify that the anchor is a number:
# ... Check whether a number is an integer (cross-platform solution):
is_int() {
  test "${1:-}" -eq "${1:-}" 2>/dev/null
}
# ... Verify that the anchor is syntactically valid:
is_int "$ANCHOR" || {
  echo "ERROR: Failed to register a new user."
  echo "Response:"
  echo "$ANCHOR_CREATION_RESPONSE"
  exit 1
} >&2

# This matches the dummy key pair generated by Internet Identity here:
# https://github.com/dfinity/internet-identity/blob/1ce860dd0601312f6521d433c4e273215a1abc5d/src/frontend/src/utils/iiConnection.ts#L57
DUMMY_PUB_KEY_BLOB='0*0\05\06\03+ep\03!\00;j\27\bc\ce\b6\a4-b\a3\a8\d0*o\0dse2\15w\1d\e2C\a6:\c0H\a1\8bY\da)'

# This is arbitrary as long as it's different from the public key above.
# We won't actually use the seed phrase. We just want to skip the warning that
# we don't have a key phrase.
SEED_PHRASE_PUB_KEY_BLOB='00000000000000000000000000000000000000000000'

add_device() {
  DEVICE_PUB_KEY_BLOB="$1"
  DEVICE_KEY_TYPE="$2"
  DEVICE_PURPOSE="$3"
  local command
  command=(dfx canister call internet_identity add "(${ANCHOR}: nat64, record { alias = \"\"; protection = variant { unprotected }; pubkey = blob \"${DEVICE_PUB_KEY_BLOB}\"; key_type = variant { ${DEVICE_KEY_TYPE} }; purpose = variant { ${DEVICE_PURPOSE} }; })" --network "$DFX_NETWORK" --candid "$(jq -r .canisters.internet_identity.candid dfx.json)")
  "${command[@]}" >/dev/null
}

echo "Adding backup device for anchor $ANCHOR."
add_device "$DUMMY_PUB_KEY_BLOB" unknown authentication
echo "Adding seed phrase for anchor $ANCHOR."
add_device "$SEED_PHRASE_PUB_KEY_BLOB" seed_phrase recovery
